---
title: "KI_Compartment_initial exploration"
output: html_document
---

```{r setup, include=FALSE}
# Set knitr options
knitr::opts_chunk$set(echo = TRUE)

# Clear working directory
rm(list=ls())

# Load necessary data
load("../data/KI_Compartment_f_coral_grouped.RData")

# Load necessary packages
library(ggplot2)
library(gridExtra)
library(Hmisc)
library(corrplot)
library(RColorBrewer)
library(VennDiagram)
library(indicspecies)
library(phyloseq)
```

```{r init, echo=FALSE, include=FALSE}
# Set colors for document
col <- c(KI2014 = "#2c7fb8", KI2015a_Pre = "#7fcdbb", KI2015a_Post = "#253494", KI2015b = "#41b6c4")

# Initialize helper function
# Helper function from http://joey711.github.io/phyloseq-demo/phyloseq-demo.html to convert phyloseq objects to vegan-friendly formatting
veganotu = function(physeq) {
  require("vegan")
  OTU = otu_table(physeq)
  if (taxa_are_rows(OTU)) {
    OTU = t(OTU)
  }
  return(as(OTU, "matrix"))
}
```


```{r subset, include=FALSE}
# Subset samples to remove KI2015c and site 34
phy97.f.c.p.comp <- subset_samples(phy97.f.c.p,field_season!="KI2015c")
phy97.f.c.sediment <- subset_samples(phy97.f.c.sediment,field_season!="KI2015c")
phy97.f.c <- subset_samples(phy97.f.c,field_season!="KI2015c")
phy97.f.c <- subset_samples(phy97.f.c,site!="34")

# Subset Sediment samples before storm
sediment.before <- subset_samples(phy97.f.c.sediment.p,
              data.frame(sample_data(phy97.f.c.sediment.p))$field_season == "KI2014",prune=TRUE)
sediment.before <- subset_taxa(sediment.before, taxa_sums(sediment.before) > 0, prune=TRUE)
# Subset Sediment samples during storm
sediment.storm <- subset_samples(phy97.f.c.sediment.p, data.frame(sample_data(phy97.f.c.sediment.p))$field_season == "KI2015a_Post", prune=TRUE)
sediment.storm <- subset_taxa(sediment.storm, taxa_sums(sediment.storm) > 0, prune=TRUE)
# Subset Sediment samples after storm
sediment.after <- subset_samples(phy97.f.c.sediment.p, data.frame(sample_data(phy97.f.c.sediment.p))$field_season == "KI2015b", prune=TRUE)
sediment.after <- subset_taxa(sediment.after, taxa_sums(sediment.after) > 0, prune=TRUE)
# Determine unique taxa (hits) in sediment time points
sediment.before.types <- unique(data.frame(tax_table(sediment.before))$hit)
sediment.storm.types <- unique(data.frame(tax_table(sediment.storm))$hit)
sediment.after.types <- unique(data.frame(tax_table(sediment.after))$hit)

# Subset Water samples before storm
water.before <- subset_samples(phy97.f.c.water.p, data.frame(sample_data(phy97.f.c.water.p))$field_season == "KI2014",prune=TRUE)
water.before <- subset_taxa(water.before, taxa_sums(water.before) > 0, prune=TRUE)
# Subset Water samples during storm
water.storm <- subset_samples(phy97.f.c.water.p, data.frame(sample_data(phy97.f.c.water.p))$field_season == "KI2015a_Post", prune=TRUE)
water.storm <- subset_taxa(water.storm, taxa_sums(water.storm) > 0, prune=TRUE)
# Subset Water samples after storm
water.after <- subset_samples(phy97.f.c.water.p, data.frame(sample_data(phy97.f.c.water.p))$field_season == "KI2015b", prune=TRUE)
water.after <- subset_taxa(water.after, taxa_sums(water.after) > 0, prune=TRUE)
# Determine unique taxa (hits) in water time points
water.before.types <- unique(data.frame(tax_table(water.before))$hit)
water.storm.types <- unique(data.frame(tax_table(water.storm))$hit)
water.after.types <- unique(data.frame(tax_table(water.after))$hit)

# Subset Coral samples before storm
coral.before <- subset_samples(phy97.f.c.coral.p, data.frame(sample_data(phy97.f.c.coral.p))$field_season == "KI2014",prune=TRUE)
coral.before <- subset_taxa(coral.before, taxa_sums(coral.before) > 0, prune=TRUE)
# Subset Coral samples during storm
coral.storm <- subset_samples(phy97.f.c.coral.p, data.frame(sample_data(phy97.f.c.coral.p))$field_season == "KI2015a_Post", prune=TRUE)
coral.storm <- subset_taxa(coral.storm, taxa_sums(coral.storm) > 0, prune=TRUE)
# Subset Coral samples after storm
coral.after <- subset_samples(phy97.f.c.coral.p, data.frame(sample_data(phy97.f.c.coral.p))$field_season == "KI2015b", prune=TRUE)
coral.after <- subset_taxa(coral.after, taxa_sums(coral.after) > 0, prune=TRUE)
# Determine unique taxa (hits) in coral time points
coral.before.types <- unique(data.frame(tax_table(coral.before))$hit)
coral.storm.types <- unique(data.frame(tax_table(coral.storm))$hit)
coral.after.types <- unique(data.frame(tax_table(coral.after))$hit)

# Subset only clade C Symbiodinium from sediment samples
phy97.f.c.sediment.C <- subset_taxa(phy97.f.c.sediment,data.frame(tax_table(phy97.f.c.sediment))$clade =="C")
# Subset only clade C Symbiodinium from water samples
phy97.f.c.water.C <- subset_taxa(phy97.f.c.water,data.frame(tax_table(phy97.f.c.water))$clade =="C")

```

```{r Ordinate and Plot}
# Constrained ordination (CAP) by field season and sample type for all samples
ord.phy97.f.c.p.comp.CAP <- ordinate(phy97.f.c.p.comp,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p1 <- plot_ordination(phy97.f.c.p.comp, ord.phy97.f.c.p.comp.CAP,
                      color="field_season", shape="SampleType",type="samples",title="") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) +
  scale_color_manual(values=col)
# Plot ordination
p1

# Constrained ordination (CAP) by field season and sample type
ord.phy97.f.c.sediment.CAP <- ordinate(phy97.f.c.sediment,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p2 <- plot_ordination(phy97.f.c.sediment, ord.phy97.f.c.sediment.CAP,
                      color="field_season", type="samples",title="Sediment") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) +
  scale_shape_manual(values = c(16,21,1,18)) +
  scale_color_manual(values=col)
# Plot ordination
p2

# Constrained ordination (CAP) by field season and sample type
ord.phy97.f.c.water.CAP <- ordinate(phy97.f.c.water,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p3 <- plot_ordination(phy97.f.c.water, ord.phy97.f.c.water.CAP,
                      color="field_season", type="samples",title="Water") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) +
  scale_shape_manual(values = c(16,21,1,18)) + 
  scale_color_manual(values=col)
# Plot ordination
p3

# Constrained ordination (CAP) by field season and sample type
ord.phy97.f.c.coral.CAP <- ordinate(phy97.f.c.coral,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p4 <- plot_ordination(phy97.f.c.coral, ord.phy97.f.c.coral.CAP,
                      color="field_season", shape="Coral_Species", 
                      type="samples",title="Coral") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) + 
  scale_color_manual(values=col)
# Plot ordination
p4

# Plot all 4 ordinations together
grid.arrange(p1,p2,p3,p4)

# Constrained ordination (CAP) by field season and sample type only Clade C
ord.phy97.f.c.sediment.C.CAP <- ordinate(phy97.f.c.sediment.C,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p5 <- plot_ordination(phy97.f.c.sediment.C, ord.phy97.f.c.sediment.C.CAP,
                      color="field_season", type="samples",title="Sediment - C only") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) +
  scale_shape_manual(values = c(16,21,1,18)) +
  scale_color_manual(values=col)
# Plot ordination
p5

# Constrained ordination (CAP) by field season and sample type only Clade C
ord.phy97.f.c.water.C.CAP <- ordinate(phy97.f.c.water.C,
                                method="CAP",distance="wunifrac",
                                formula= ~ field_season + SampleType)
# Create ordination plot
p6 <- plot_ordination(phy97.f.c.water.C, ord.phy97.f.c.water.C.CAP,
                      color="field_season", type="samples",title="Water - C only") +
  stat_ellipse(aes(group=c(field_season)), type = "t",level=0.95,lty=2) +
  scale_shape_manual(values = c(16,21,1,18)) +
  scale_color_manual(values=col)
# Plot ordination
p6
```

```{r Plot exploration}
# Extract tax table
tt <- data.frame(tax_table(phy97.f.c.sediment))

# Bar plots
plot_bar(phy97.f.c.sediment.p, fill="clade") + facet_grid(site ~ field_season)
plot_bar(phy97.f.c.water.p, fill="clade") + facet_grid(site ~ field_season)

# Heatmap
plot_heatmap(phy97.f.c.water) + facet_grid(. ~ field_season)

# subset to taxa sums > 50
water <- subset_taxa(physeq = phy97.f.c.water,taxa_sums(phy97.f.c.water) >50)
sediment <- subset_taxa(physeq = phy97.f.c.sediment,taxa_sums(phy97.f.c.sediment) >50)

# Heatmaps
plot_heatmap(water,sample.label = "field_season",sample.order = "field_season",method = "RDA",distance = "none",taxa.label = "hit")
plot_heatmap(sediment,sample.label = "field_season",sample.order = "field_season",method = "NMDS",distance = "jaccard",taxa.label = "hit")

# Network plots
plot_net(water,color="site")
plot_net(sediment,color="site")

# Bar plots
plot_bar(sediment.before, fill="clade")
plot_bar(sediment.storm, fill="clade")
plot_bar(sediment.after, fill="clade")
```

```{r Prep for Vegan}
# Use veganotu function to convert to vegan-friendly formatting
water.veg <- veganotu(water)
sediment.veg <- veganotu(sediment)
all.veg <- veganotu(phy97.f.c.p)
```

```{r Correlation Matrices}
# Calculate correlation matrix
water.cor <- cor(water.veg, method = c("pearson"))
# Use Hmisc package to calculate correlation matrix with statistical significance
water.rcorr <- rcorr(as.matrix(water.veg))
# platy.rcorr$P
# platy.rcorr$r

# Use corrplot package to plot correlation matrix in a human-readable format
# Set p > 0.05
corrplot(water.rcorr$r, type="upper", order="AOE", 
         p.mat = water.rcorr$P, sig.level = 0.05, insig = "blank", method="square",
         col = rev(brewer.pal(n = 8, name = "RdBu")),tl.col = "black")
```

```{r Venn Diagrams}
# Create a Venn diagram
venn.diagram(x=list("Sediment Before"=sediment.before.types,"Sediment Storm"=sediment.storm.types,"Sediment After"=sediment.after.types),file = "Sediment_Venn.jpg", col=rainbow(3),fill=rainbow(3), margin=0.1,main = "Sediment Types")

# Make lists of common/different taxa
sediment.storm.only <- sediment.storm.types[which(!(sediment.storm.types %in% sediment.before.types) & !(sediment.storm.types %in% sediment.after.types))]
sediment.not.storm <- sediment.before.types[which(!(sediment.before.types %in% sediment.storm.types) & (sediment.before.types %in% sediment.after.types))]
# Make lists of common/different taxa
sediment.befstaf <- sediment.before.types[which(sediment.before.types %in% sediment.storm.types & (sediment.before.types %in% sediment.after.types))]
sediment.notbef.staf <- sediment.after.types[which(!(sediment.after.types %in% sediment.before.types) & (sediment.after.types %in% sediment.storm.types))]
sediment.befst.notaf <- sediment.before.types[which(!(sediment.before.types %in% sediment.after.types) & (sediment.before.types %in% sediment.storm.types))]
sediment.befonly <- sediment.before.types[which(!(sediment.before.types %in% sediment.after.types) & !(sediment.before.types %in% sediment.storm.types))]
sediment.afonly <- sediment.after.types[which(!(sediment.after.types %in% sediment.before.types) & !(sediment.after.types %in% sediment.storm.types))]

# Make Venn Diagram
venn.diagram(x=list("water Before"=water.before.types,"water Storm"=water.storm.types,"water After"=water.after.types),file = "water_Venn.jpg", col=rainbow(3),fill=rainbow(3), margin=0.1,main = "water Types")

# Make lists of common/different taxa
water.storm.only <- water.storm.types[which(!(water.storm.types %in% water.before.types) & !(water.storm.types %in% water.after.types))]
water.not.storm <- water.before.types[which(!(water.before.types %in% water.storm.types) & (water.before.types %in% water.after.types))]
# Make lists of common/different taxa
water.befstaf <- water.before.types[which(water.before.types %in% water.storm.types & (water.before.types %in% water.after.types))]
water.notbef.staf <- water.after.types[which(!(water.after.types %in% water.before.types) & (water.after.types %in% water.storm.types))]
water.befst.notaf <- water.before.types[which(!(water.before.types %in% water.after.types) & (water.before.types %in% water.storm.types))]
water.befonly <- water.before.types[which(!(water.before.types %in% water.after.types) & !(water.before.types %in% water.storm.types))]
water.afonly <- water.after.types[which(!(water.after.types %in% water.before.types) & !(water.after.types %in% water.storm.types))]

# Make a Venn Diagram
venn.diagram(x=list("coral Before"=coral.before.types,"coral Storm"=coral.storm.types,"coral After"=coral.after.types),file = "coral_Venn.jpg", col=rainbow(3),fill=rainbow(3), margin=0.1,main = "coral Types")

# Make lists of common/different taxa
coral.storm.only <- coral.storm.types[which(!(coral.storm.types %in% coral.before.types) & !(coral.storm.types %in% coral.after.types))]
coral.not.storm <- coral.before.types[which(!(coral.before.types %in% coral.storm.types) & (coral.before.types %in% coral.after.types))]
# Make lists of common/different taxa
coral.befstaf <- coral.before.types[which(coral.before.types %in% coral.storm.types & (coral.before.types %in% coral.after.types))]
coral.notbef.staf <- coral.after.types[which(!(coral.after.types %in% coral.before.types) & (coral.after.types %in% coral.storm.types))]
coral.befst.notaf <- coral.before.types[which(!(coral.before.types %in% coral.after.types) & (coral.before.types %in% coral.storm.types))]
coral.befonly <- coral.before.types[which(!(coral.before.types %in% coral.after.types) & !(coral.before.types %in% coral.storm.types))]
coral.afonly <- coral.after.types[which(!(coral.after.types %in% coral.before.types) & !(coral.after.types %in% coral.storm.types))]
```
# Why use pcoa?
We use PCoA because the inputs to adonis(), betadisper, etc are dissimilarity matrices and the aim is to show t
hose dissimilarities (and the group centroids/dispersions) as best as possible whilst preserving the direct link to the distance values (ie why we don't use NMDS).
https://stat.ethz.ch/pipermail/r-sig-ecology/2013-August/004011.html

